struct PairOfbalances {
  int keyIndex;
  int value;
}

struct PairOfb1 {
  int keyIndex;
  bool value;
}

struct PairOfb2 {
  int keyIndex;
  bytes value;
}

contract Coin {
  @state
  public PubKeyHash minter;

  @state
  public HashedMap<PubKeyHash, int> balances;

  @state
  public HashedMap<PubKeyHash, bool> b1;

  @state
  public HashedMap<PubKeyHash, bytes> b2;

  constructor(PubKeyHash msgSender) {
    this.minter = msgSender;
  }

  public function mint(PubKeyHash receiver, int amount, Sig sig, PubKey pubKey, PairOfb1 b1_receiver, 
    PairOfb2 b2_receiver, PairOfbalances balances_receiver, SigHashPreimage txPreimage) {
    bool ret = false;
    bool returned = false;
    PubKeyHash msgSender = hash160(pubKey);
    require(checkSig(sig, pubKey));
    if (msgSender != this.minter) {
      {
        ret = true;
        returned = true;
      }
    }
    if (!returned) {
      require(this.checkPairOfbalances(receiver, balances_receiver));
      balances_receiver.value += amount;
      require(this.checkPairOfb1(receiver, b1_receiver));
      b1_receiver.value != true;
      require(this.checkPairOfb2(receiver, b2_receiver));
      b2_receiver.value = b'0001';
    }
    require(this.b2.set(receiver, b2_receiver.value, b2_receiver.keyIndex));
    require(this.balances.set(receiver, balances_receiver.value, balances_receiver.keyIndex));
    require(this.propagateState(txPreimage, SigHash.value(txPreimage)));
  }

  public function send(PubKeyHash receiver, int amount, bool a, bytes b, Sig sig, PubKey pubKey, PairOfb1 b1_receiver, PairOfb2 b2_receiver, 
    PairOfbalances balances_msgSender, PairOfbalances balances_receiver, SigHashPreimage txPreimage) {
    bool ret = false;
    bool returned = false;
    PubKeyHash msgSender = hash160(pubKey);
    require(checkSig(sig, pubKey));
    require(this.checkPairOfbalances(msgSender, balances_msgSender));
    if (balances_msgSender.value < amount) {
      {
        ret = true;
        returned = true;
      }
    }
    if (!returned) {
      balances_msgSender.value -= amount;
      require(this.checkPairOfbalances(receiver, balances_receiver));
      balances_receiver.value += amount;
      require(this.checkPairOfb1(receiver, b1_receiver));
      b1_receiver.value != a;
      require(this.checkPairOfb2(receiver, b2_receiver));
      b2_receiver.value = b;
    }
    require(this.b2.set(receiver, b2_receiver.value, b2_receiver.keyIndex));
    require(this.balances.set(msgSender, balances_msgSender.value, balances_msgSender.keyIndex));
    require(this.balances.set(receiver, balances_receiver.value, balances_receiver.keyIndex));
    require(this.propagateState(txPreimage, SigHash.value(txPreimage)));
  }

  function propagateState(SigHashPreimage txPreimage, int value) : bool {
    require(Tx.checkPreimage(txPreimage));
    bytes outputScript = this.getStateScript();
    bytes output = Utils.buildOutput(outputScript, value);
    return hash256(output) == SigHash.hashOutputs(txPreimage);
  }

  function checkPairOfbalances(PubKeyHash key, PairOfbalances pair) : bool {
    return this.balances.has(key, pair.keyIndex) ? this.balances.canGet(key, pair.value, pair.keyIndex) : pair.value == 0;
  }

  function checkPairOfb1(PubKeyHash key, PairOfb1 pair) : bool {
    return this.b1.has(key, pair.keyIndex) ? this.b1.canGet(key, pair.value, pair.keyIndex) : pair.value == false;
  }

  function checkPairOfb2(PubKeyHash key, PairOfb2 pair) : bool {
    return this.b1.has(key, pair.keyIndex) ? this.b2.canGet(key, pair.value, pair.keyIndex) : pair.value == b'';
  }
}