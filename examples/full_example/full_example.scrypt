
struct Card {
    int v;
    int s;
}

/**
* library Process state
*/
library State {
        
        static const int Running = 0;
        static const int Sleeping = 1;
        static const int Waiting = 2;
        static const int Stopped = 3;
        static const int Zombie = 4;
        static const int StateCount = 5;
}

library Suit {
        
        static const int club = 0;
        static const int diamonds = 1;
        static const int hearts = 2;
        static const int spades = 3;
}

library Value {
        
        static const int two = 0;
        static const int three = 0;
        static const int four = 0;
        static const int five = 0;
        static const int six = 0;
        static const int seven = 0;
        static const int eight = 0;
        static const int nine = 0;
        static const int ten = 0;
        static const int jack = 0;
        static const int queen = 0;
        static const int king = 0;
        static const int ace = 0;
}


// cards
   
contract full_example {
    

        // Variables in contract storage
  
        int _state;
        int pid;
        static int reaped = 3;

        
        static Card card1 = {Value.two, Suit.club};
        static Card card2 = {Value.two, Suit.club};

        // Constants
        static const int bad_state = State.Zombie;
        static int  first_pid = 1;

        // Reading but not writing contract storage means function
        // can be declared view
        function is_zombie_reaper() : bool {
                /* must be pid 1 and not zombie ourselves */
                return (this.pid == first_pid && this._state != State.Zombie);
        }

        // Returning a constant does not access storage at all, so
        // function can be declared pure
        function systemd_pid() : int {
                // Note that cast is required to change sign from
                // int32 to uint32
                return first_pid;
        }

        /// Convert celcius to fahrenheit
        function celcius2fahrenheit(int celcius) : int {
                int fahrenheit = celcius * 9 / 5 + 32;

                return fahrenheit;
        }

        /// Convert fahrenheit to celcius
        function fahrenheit2celcius(int fahrenheit) : int {
                return (fahrenheit - 32) * 5 / 9;
        }

        /// is this number a power-of-two
        function is_power_of_2(int n) : bool {
            
                return n != 0 && unpack((num2bin(n, 32) & num2bin(n - 1, 32))) == 0;
        }

        /// calculate the population count (number of set bits) using Brian Kerningham's way
        function population_count(int n) : int {
                int counter = 0;
                loop (10) {
                   if(n != 0) {
                        counter++;
                        //n &= (n - 1);
                   }
                }
                return counter;
        }

        /// calculate the power of base to exp
        function power(int base, int exp) : int {
                int result = 1;
                loop (10) : i {

                        if(i < exp) {
                                result = result * base;
                        }
                        
                }
                return result;
        }

        /// returns true if the address is 0
        function is_address_zero(Ripemd160 a) : bool {
                return a == Ripemd160(b'0000000000000000000000000000000000000000');
        }

        /// reverse the bytes in an array of 8 (endian swap)
        function byte8reverse(bytes input) : bytes {
                bytes out = b'';
                out = ((input << 56) & b'ff00000000000000') |
                          ((input << 40) & b'00ff000000000000') |
                          ((input << 24) & b'0000ff0000000000') |
                          ((input <<  8) & b'000000ff00000000') |
                          ((input >>  8) & b'00000000ff000000') |
                          ((input >> 24) & b'0000000000ff0000') |
                          ((input >> 40) & b'000000000000ff00') |
                          ((input >> 56) & b'00000000000000ff');
                return out;
        }

        /// This mocks a pid state
        function get_pid_state(int _pid) : int {
                int n = 8;
                loop (9) : i_ {
                     int i = i_ + 1;
                     if ((i % 3) == 0) {
                                n *= _pid / i;
                        } else {
                                n /= 3;
                        }   
                }
               

                return n % State.StateCount;
        }

        /// Overloaded function with different return value!
        function get_pid_state2() : int {
                return reaped;
        }

        function reap_processes() : bool {
                int n = 0;

                loop (100) : i {
                    if(n < 100) {
                        if (this.get_pid_state(n) == State.Zombie) {
                                // reap!
                                reaped += 1;
                        }
                        n++;
                    }
                } 

                return true;
        }

        function run_queue() : int {
                int count = 0;
                // no initializer means its 0.
                int n=0;
                bool done = false;
                loop (1000) : i {
                    if(!done) {
                        if (this.get_pid_state(n) == State.Waiting) {
                                count++;
                        }
                        ++n;
                        if(n < 1000) {
                           done = true;
                        }
                    }
                } 

                return count;
        }



        // This function does a lot of copying
        function set_card1(Card  c) : Card {
                Card previous = card1;
                card1 = c;
                return previous;
        }

        /// return the ace of spades
        function ace_of_spaces() : Card {
                return {Suit.spades, Value.ace };
        }

        /// score card
        function score_card(Card  c) : int {
            int score = 0;
                if (c.s == Suit.hearts) {
                        if (c.v == Value.ace) {
                                score = 14;
                        }
                        if (c.v == Value.king) {
                                score = 13;
                        }
                        if (c.v == Value.queen) {
                                score = 12;
                        }
                        if (c.v == Value.jack) {
                                score = 11;
                        }
                }
            return score;
                // all others score 0
        }
}